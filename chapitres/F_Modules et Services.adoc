=== Modules : Notion de module
- AngularJS propose la notion de *module*
- Un module permet d'encapsuler un ensemble de fonctionnalités
  - Code de configuration
  - Services, contrôleurs, directives et filtres
- Avantages
  - Architecture modulaire
  - Réutilisabilité
  - Testabilité (module de test, module de production)
- Le module *ng* fournit toutes les fonctionnalités vues jusqu'ici
  - Automatiquement importé



=== Modules : Notion de module
- De manière générale, les modules peuvent être organisés
  - Par type (services, contrôleurs...)
  - Par fonctionnalité ("gestion des contacts", "admin"...)
- On peut par exemple utiliser le découpage suivant
  - Un module par type de composant (services, contrôleurs...)
  - Un module applicatif qui importe les précédents, ainsi que les modules tierce-partie

<figure>
    <img src="ressources/images/modules.png" alt="Modules"  width="60%"/>
</figure>



=== Modules : Déclarer un module
- La fonction `angular.module` permet de déclarer un module
```javascript
var Foo = angular.module('Foo', []);
```
- Exemple
```javascript
var Services    = angular.module('Services',    []);
var Controllers = angular.module('Controllers', []);
var MyApplication = 
    angular.module('Application',
        ['Services','Controllers']);
```
- La directive `ng-app` permet de spécifier le module applicatif
```
<html ng-app='Application'>
```



=== Modules : Configuration
- Un module dispose de deux fonctions d'initialisation
  - `config()` : appelée au chargement du module
  - `run()` : appelée lorsque tous les modules ont été chargés

```javascript
var App = angular.module('App', []);

App.config(function() { 
    console.log('Chargement...');
});

App.run(function() { 
    console.log('Initialisation...');
});
```
- Utile pour configurer l'application au démarrage (ex : le routage des URLs vers les vues)



=== Modules et Composants : Factories
- Un module instancie et expose des composants (services, contrôleurs, directives et filtres) grâce à des fonctions *factory*
  - `service(name, configFn)`
  - `controller(name, configFn)`
  - `directive(name, configFn)`
  - `filter(name, configFn)`
- Exemple : déclaration d'un contrôleur

```javascript
var Controllers = angular.module('Controllers', []);
Controllers.controller('PeopleCtrl', function($scope) {
    $scope.names = ['you', 'me', 'them'];
    $scope.add = function () { … };
});
```



=== Modules et composants : service() vs factory()
- Il existe une méthode alternative pour créer un service
  - Méthode `<module>.factory(nom, configFn)`
  - Permet d'exécuter du code avant d'instancier le service
- Différences
  - Avec `service()`, this fait référence à l'instance du service en cours de création.
  - Avec `factory()`, il faut instancier manuellement le service et retourner la nouvelle instance. this fait référence au module.



=== Modules et composants : service() vs factory()
- Avec `module.service()`

```javascript
<module>.service('PeopleSrvc', function() {
    this.foo = 42;
    this.bar = function() { … };
});
```

- Avec `module.factory()`

```javascript
<module>.factory('PeopleSrvc', function() {
    var instance = {};
    instance.foo = 42;
    instance.bar = function() { … };
    return instance;
});
```



=== Modules : Valeurs
- Pour finir, un module peut exposer des valeurs
  - Réutilisabilité, principe DRY
  - Injectables dans les composants
- Utilisation de la fonction factory `module.value`

```javascript
<module>.value('Answer', 42);

<module>.service('Q', function(Answer) {
    this.answerMe = function(anyQuestion) {
        return Answer;
    }
});
```



=== Injection de dépendances
- AngularJS propose un mécanisme d'*injection de dépendances*
- Principe : un composant ne va pas chercher lui-même ses dépendances, mais attend qu'on les lui fournisse
  - Aussi appelé *IOC* (Inversion Of Control)
- Avantages
  - Simplifie le code
  - Permet de varier les implémentations d'une dépendance (production vs mock)



=== Injection de dépendances : Injection dans un module
- Dans le cas d'un module
  - Les dépendances envers les autres modules sont déclarées dans le tableau des dépendances
  - Les fonctions d'initialisation `run` et `config` acceptent également des dépendances en paramètre 

```javascript
// dépendance envers les modules annexes Services et Controllers
var App = angular.module('App', ['Services','Controllers']);

// injection du service $routeProvider
App.config(function($routeProvider) { 
    $routeProvider.when(…);
});
```



=== Injection de dépendances : Injection dans un service, contrôleur...
- Dans le cas des services, contrôleurs, filtres et directives, les dépendances sont déclarées comme des paramètres de la fonction de configuration

```javascript
Services.service('PeopleSrvc', function() {
	…
});

// le $scope des contrôleurs est également une dépendance
// injectée !
Controllers.
    controller('PeopleCtrl', function($scope, PeopleSrvc) {
		…
	});
```



=== Injection de dépendances : Minification et obfuscation
- AngularJS se base sur le nom du paramètre pour déterminer la dépendance à injecter
  - Nom défini lors de son instanciation par le module
- Problème : en cas de minification et/ou obfuscation du code, les variables, fonctions et paramètres sont renommés !
  - Avant
```javascript
ControllersCtrls.controller('PeopleCtrl', function($scope) {
     (...)
});
```

  - Après
```javascript
var$21.func$33('PeopleCtrl', function(param$13) {
     (...)
});
```



=== Injection de dépendances : Minification et obfuscation
- Solution : une notation alternative permet de préciser les dépendances sous forme de String
  - Les Strings ne sont pas minifiées ni obfusquées 
- Utilisation d'un tableau
  - Les N premiers éléments sont les noms des dépendances
  - Le dernier élément est la fonction de configuration
  - L'ordre des noms doit correspondre à celui des paramètres
```javascript
<module>.controller('MyCtrl',['foo','bar',function(foo,bar){
     foo.(…);
     bar.(…);
}]);
```

tp4